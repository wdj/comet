<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>MAGMA_tally4: Sparse-Iter</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="magma_tally4-logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">MAGMA_tally4
   &#160;<span id="projectnumber">1.6.2</span>
   </div>
   <div id="projectbrief">Matrix Algebra for GPU and Multicore Architectures</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('sparse-iter.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Sparse-Iter </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>The MAGMA_tally4 Sparse-Iter Package </h1>
<p>The sparse-iter package recently added to the MAGMA_tally4 software stack contains sparse BLAS routines as well as functions to handle the complete iterative solution process of a sparse linear system of equations.</p>
<p>A typical application includes:</p><ul>
<li>an interface passing the linear system to MAGMA_tally4</li>
<li>choosing the desired data structures for the respective sparse BLAS functions</li>
<li>sending the data structures to the device</li>
<li>choosing solver, eigensolver, and preconditioner</li>
<li>solving the respective system on the device</li>
<li>passing back the results</li>
</ul>
<p>For each of these steps, multiple options are offered by the MAGMA_tally4 software stack.</p>
<h1><a class="anchor" id="datastructures"></a>
Sparse Data Structures </h1>
<p>For a more generic programming approach, the sparse data structures (matrices and vectors) are stored in data structures containing all information necessary to access the sparse-BLAS via wrappers: </p><pre class="fragment">struct magma_tally4_z_matrix{
    magma_tally4_storage_t    storage_type;            // matrix format - CSR, ELL, SELL-P
    magma_tally4_location_t   memory_location;         // CPU or DEV
    magma_tally4_symmetry_t   sym;                     // opt: indicate symmetry
    magma_tally4_diagorder_t  diagorder_type;          // opt: only needed for factorization matrices
    magma_tally4_fillmode_t   fill_mode;               // fill mode full/lower/upper
    magma_tally4_int_t        num_rows;                // number of rows
    magma_tally4_int_t        num_cols;                // number of columns
    magma_tally4_int_t        nnz;                     // opt: number of nonzeros
    magma_tally4_int_t        max_nnz_row;             // opt: max number of nonzeros in one row
    magma_tally4_int_t        diameter;                // opt: max distance of entry from main diagonal
    union {
        magma_tally4DoubleComplex      *val;           // array containing values in CPU case
        magma_tally4DoubleComplex_ptr  dval;           // array containing values in DEV case
    };
    union {
        magma_tally4DoubleComplex      *diag;          // opt: diagonal entries in CPU case
        magma_tally4DoubleComplex_ptr  ddiag;          // opt: diagonal entries in DEV case
    };
    union {
        magma_tally4_index_t           *row;           // row pointer CPU case
        magma_tally4Index_ptr          drow;           // row pointer DEV case
    };
    union {
        magma_tally4_index_t           *rowidx;        // opt: array containing row indices CPU case
        magma_tally4Index_ptr          drowidx;        // opt: array containing row indices DEV case
    };
    union {
        magma_tally4_index_t           *col;           // array containing col indices CPU case
        magma_tally4Index_ptr          dcol;           // array containing col indices  DEV case
    };
    magma_tally4_index_t      *blockinfo;              // opt: for BCSR format CPU case
    magma_tally4_int_t        blocksize;               // opt: info for SELL-P/BCSR
    magma_tally4_int_t        numblocks;               // opt: info for SELL-P/BCSR
    magma_tally4_int_t        alignment;               // opt: info for SELL-P/BCSR
}magma_tally4_z_matrix;

struct magma_tally4_z_matrix{
    magma_tally4_location_t   memory_location;         // CPU or DEV
    magma_tally4_int_t        num_rows;                // number of rows
    magma_tally4_int_t        num_cols;                // number of columns (in case of a block of vectors)
    magma_tally4_int_t        nnz;                     // opt: number of nonzeros
    union {
        magma_tally4DoubleComplex      *val;           // array containing values in CPU case
        magma_tally4DoubleComplex_ptr  dval;           // array containing values in DEV case
    };
    magma_tally4_order_t      major;                   // storage type:Row/Column-Major
}magma_tally4_z_matrix;
</pre><p>The purpose of the unions (e.g. for the val array) is to support different hardware platforms, where the magma_tally4XXX_ptr is adapted to the respective device characteristics.</p>
<p>For sparse matrices, the main formats are CSR, ELL and the MAGMA_tally4-specific SELL-P. Generally, the sparse-BLAS routines provide for these the best performance.</p>
<p>Without specifying the storage type, the memory location or the dimension of the matrix, the sparse matrix vector product can then be used via the wrapper: </p><pre class="fragment">magma_tally4_z_spmv(
        magma_tally4DoubleComplex alpha,
        magma_tally4_z_matrix A,
        magma_tally4_z_matrix x,
        magma_tally4DoubleComplex beta,
        magma_tally4_z_matrix y,
        magma_tally4_queue_t queue );
</pre><h1><a class="anchor" id="io"></a>
Sparse I/O </h1>
<p>A sparse matrix stored in mtx format can be read from disk via the function: </p><pre class="fragment">magma_tally4_z_csr_mtx(
        magma_tally4_z_matrix *A,
        const char *filename,
        magma_tally4_queue_t queue );
</pre><p>A sparse linear system of dimension mxn present in main memory can be passed to MAGMA_tally4 via the function: </p><pre class="fragment">magma_tally4_zcsrset(
        magma_tally4_int_t m,
        magma_tally4_int_t n,
        magma_tally4_index_t *row,
        magma_tally4_index_t *col,
        magma_tally4DoubleComplex *val,
        magma_tally4_z_matrix *A,
        magma_tally4_queue_t queue );
</pre><p>where row, col, val contain the matrix in CSR format.</p>
<p>If the matrix is already present in DEV memory, the corresponding function is </p><pre class="fragment">magma_tally4_zcsrset_gpu(
    magma_tally4_int_t m,
    magma_tally4_int_t n,
    magma_tally4Index_ptr row,
    magma_tally4Index_ptr col,
    magma_tally4DoubleComplex_ptr val,
    magma_tally4_z_matrix *A,
    magma_tally4_queue_t queue );
</pre><p>Similarly, matrices handled in MAGMA_tally4 can be returned via the functions </p><pre class="fragment">magma_tally4_zcsrget(
    magma_tally4_z_matrix A,
    magma_tally4_int_t *m,
    magma_tally4_int_t *n,
    magma_tally4_index_t **row,
    magma_tally4_index_t **col,
    magma_tally4DoubleComplex **val,
    magma_tally4_queue_t queue );

magma_tally4_zcsrget_gpu(
    magma_tally4_z_matrix A,
    magma_tally4_int_t *m,
    magma_tally4_int_t *n,
    magma_tally4Index_ptr *row,
    magma_tally4Index_ptr *col,
    magma_tally4DoubleComplex_ptr *val,
    magma_tally4_queue_t queue );

respectively

write_z_csrtomtx(
    magma_tally4_z_matrix A,
    const char *filename,
    magma_tally4_queue_t queue );
</pre><p>Additionally, MAGMA_tally4 contains routines to generate stencil discretizations of different kind.</p>
<p>Vectors can be initiated inside MAGMA_tally4 via </p><pre class="fragment">magma_tally4_z_vinit(
    magma_tally4_z_matrix *x,
    magma_tally4_location_t memory_location,
    magma_tally4_int_t num_rows,
    magma_tally4DoubleComplex values,
    magma_tally4_queue_t queue );
</pre><p>where ''memory_location'' sets the location (Magma_tally4_CPU or Magma_tally4_DEV). Also, vectors can be read from file via </p><pre class="fragment">magma_tally4_z_vread(
    magma_tally4_z_matrix *x,
    magma_tally4_int_t length,
    char * filename,
    magma_tally4_queue_t queue );
</pre><p>or - in case of a block of sparse vectors stored as CSR matrix - via </p><pre class="fragment">magma_tally4_z_vspread(
    magma_tally4_z_matrix *x,
    const char * filename,
    magma_tally4_queue_t queue );
</pre><p>or passed from/to main memory: </p><pre class="fragment">magma_tally4_zvset(
    magma_tally4_int_t m,
    magma_tally4_int_t n,
    magma_tally4DoubleComplex *val,
    magma_tally4_z_matrix *b,
    magma_tally4_queue_t queue );

magma_tally4_zvget(
    magma_tally4_z_matrix b
    magma_tally4_int_t *m,
    magma_tally4_int_t *n,
    magma_tally4DoubleComplex **val,
    magma_tally4_queue_t queue );
</pre><h1><a class="anchor" id="formats"></a>
Matrix Formats </h1>
<p>To convert a matrix from one into another format, the CPU-based routine </p><pre class="fragment">magma_tally4_z_mconvert(
    magma_tally4_z_matrix A,
    magma_tally4_z_matrix *B,
    magma_tally4_storage_t old_format,
    magma_tally4_storage_t new_format,
    magma_tally4_queue_t queue );
</pre><p>can be used where old_format and new_format determine the specific conversion.</p>
<h1><a class="anchor" id="memorhandling"></a>
Memory Handling </h1>
<p>All iterative solvers and eigensolvers included in the sparse-iter package work on the device. Hence, it is required to send the respective data structures to the device for solving, and back to access the solution. The functions </p><pre class="fragment">magma_tally4_z_mtransfer(
    magma_tally4_z_matrix A,
    magma_tally4_z_matrix *B,
    magma_tally4_location_t src,
    magma_tally4_location_t dst,
    magma_tally4_queue_t queue );

magma_tally4_z_vtransfer(
    magma_tally4_z_matrix x,
    magma_tally4_z_matrix *y,
    magma_tally4_location_t src,
    magma_tally4_location_t dst,
    magma_tally4_queue_t queue );
</pre><p>allow any data copy operation - from host to device, device to device, device to host or host to host.</p>
<p>Linear algebra objects can be deallocated via </p><pre class="fragment">magma_tally4_z_mfree(
    magma_tally4_z_matrix *A,
    magma_tally4_queue_t queue );

magma_tally4_z_vfree(
    magma_tally4_z_matrix *x,
    magma_tally4_queue_t queue );
</pre><h1><a class="anchor" id="sparsesolvers"></a>
Iterative Solvers </h1>
<p>The sparse-iter package contains a variety of linear solvers, eigensolvers, and preconditioners. The standard procedure to call a solver is to pass the linear algebra objects (located on the device) and a structure called magma_tally4_z_solver_par (respectively and magma_tally4_z_precond_par) controlling the iterative solver and collecting information during the execution: </p><pre class="fragment">struct magma_tally4_z_solver_par{
    magma_tally4_solver_type  solver;                  // solver type
    magma_tally4_int_t        version;                 // sometimes there are different versions
    double             epsilon;                 // relative residual stopping criterion
    magma_tally4_int_t        maxiter;                 // upper iteration limit
    magma_tally4_int_t        restart;                 // for GMRES
    magma_tally4_ortho_t      ortho;                   // for GMRES
    magma_tally4_int_t        numiter;                 // feedback: number of needed iterations
    double             init_res;                // feedback: initial residual
    double             final_res;               // feedback: final residual
    double             iter_res;                // feedback: iteratively computed residual
    real_Double_t      runtime;                 // feedback: runtime needed
    real_Double_t      *res_vec;                // feedback: array containing residuals
    real_Double_t      *timing;                 // feedback: detailed timing
    magma_tally4_int_t        verbose;                 // print residual ever 'verbose' iterations
    magma_tally4_int_t        num_eigenvalues;         // number of EV for eigensolvers
    magma_tally4_int_t        ev_length;               // needed for framework
    double             *eigenvalues;            // feedback: array containing eigenvalues
    magma_tally4DoubleComplex *eigenvectors;           // feedback: array containing eigenvectors
    magma_tally4_int_t        info;                    // feedback: did the solver converge etc
}magma_tally4_z_solver_par;
</pre><p>These entities can either be initialized manually, or via the function </p><pre class="fragment">magma_tally4_zsolverinfo_init(
    magma_tally4_z_solver_par *solver_par,
    magma_tally4_z_preconditioner *precond,
    magma_tally4_queue_t queue );
</pre><p>setting them to some default values. For eigensolvers, the workspace needed for the eigenvectors has to be allocated consistent with the matrix dimension, which requires additionally calling </p><pre class="fragment">magma_tally4_zeigensolverinfo_init(
    magma_tally4_z_solver_par *solver_par,
    magma_tally4_queue_t queue );
</pre><p>after setting solver_par.ev_length and solver_par.num_eigenvalues to the correct numbers.</p>
<p>An easy way to access the data collected during a solver execution is given by the function </p><pre class="fragment">magma_tally4_zsolverinfo(
    magma_tally4_z_solver_par *solver_par,
    magma_tally4_z_preconditioner *precond_par,
    magma_tally4_queue_t queue );
</pre><p>After completion, </p><pre class="fragment">magma_tally4_zsolverinfo_free(
    magma_tally4_z_solver_par *solver_par,
    magma_tally4_z_preconditioner *precond,
    magma_tally4_queue_t queue );
</pre><p>deallocates all memory used within the solver and preconditioner structure.</p>
<p>A solver can then be called via </p><pre class="fragment">magma_tally4_z*solvername*(
    magma_tally4_z_matrix A,
    magma_tally4_z_matrix b,
    magma_tally4_z_matrix *x,
    magma_tally4_z_solver_par *solver_par,
    magma_tally4_queue_t queue );
</pre><p>respectively </p><pre class="fragment">magma_tally4_z*solvername*(
    magma_tally4_z_matrix A,
    magma_tally4_z_matrix b,
    magma_tally4_z_matrix *x,
    magma_tally4_z_solver_par *solver_par,
    magma_tally4_z_preconditioner *precond_par,
    magma_tally4_queue_t queue );
</pre><p>More conveniant is the use the wrapper </p><pre class="fragment">magma_tally4_z_solver(
    magma_tally4_z_matrix A, magma_tally4_z_matrix b,
    magma_tally4_z_matrix *x, magma_tally4_zopts *zopts,
    magma_tally4_queue_t queue );
</pre><p>where zopts is a structure containing both, the solver and the preconditioner information: struct magma_tally4_zopts{ magma_tally4_z_solver_par solver_par; magma_tally4_z_preconditioner precond_par; magma_tally4_storage_t input_format; int blocksize; int alignment; magma_tally4_storage_t output_format; magma_tally4_location_t input_location; magma_tally4_location_t output_location; magma_tally4_scale_t scaling; }magma_tally4_zopts;</p>
<p>All entities of this structure can be initialized from command line by calling </p><pre class="fragment">magma_tally4_zparse_opts(
    int argc,
    char** argv,
    magma_tally4_zopts *opts,
    int *matrices,
    magma_tally4_queue_t queue );
</pre><h1><a class="anchor" id="sparseexample"></a>
Example </h1>
<p>Especially when using sparse-iter for the first time, the easiest way to get familiar with the package is to use and modify one of the predefined testers.</p>
<p>In the following example we assume to have an application coded in C and running in double precision that at some instance requires solving a linear system of the form Ax=b, where A and b are generated within the application. Furthermore, we assume that the matrix A is in CSR format together with a RHS vector b in present in main memory. We do not know which solver and preconditioner combination works best for this problem, and which data format gives the best sparse-BLAS performance. For this purpose we extract parts of the testing_dsolver.cpp located in the sparse-iter/testing folder.</p>
<p>First, we copy the includes, initialization and finalization into our application program. Then we focus on the linear system we want to solve. We extract line 34-54 and copy it into the right location. This includes the setup of the solver parameters via command line. As we do not want to read the linear system from file, but solve the system present in memory, we use </p><pre class="fragment">    magma_tally4_dcsrset( m, n, row, col, val, &amp;A, queue );
</pre><p>to pass the matrix (present in row, col val) and </p><pre class="fragment">    magma_tally4_dvset( m, n, valb, &amp;b, queue );
</pre><p>to pass the RHS vector b (entries in valb) to MAGMA_tally4. For the solution vector, we allocate an initial guess on the device via: </p><pre class="fragment">    magma_tally4_d_vector x_d;
    magma_tally4_d_vinit( &amp;x_d, Magma_tally4_DEV, A.num_cols, one, queue );
</pre><p>We then copy line 74-78 into the application to convert the matrix into the preferred format and copy it to the device. The RHS is transferred via </p><pre class="fragment">    magma_tally4_d_vector b_d;
    magma_tally4_d_vtransfer( b, &amp;b_d, Magma_tally4_CPU, Magma_tally4_DEV, queue );
</pre><p>We solve with </p><pre class="fragment">    magma_tally4_d_solver( B_d, b_d, &amp;x_d, &amp;zopts, queue );
</pre><p>and return the solution vector to the application via </p><pre class="fragment">    magma_tally4_int_t m, n;
    double * valx;
    magma_tally4_dvget( x_d, &amp;m, &amp;n, &amp;valx, queue );
</pre><p>Finally, we clean up the used memory via </p><pre class="fragment">    magma_tally4_z_mfree(&amp;B_d, queue );
    magma_tally4_z_mfree(&amp;B, queue );
    magma_tally4_z_vfree(&amp;x_d, queue );
    magma_tally4_z_vfree(&amp;b_d, queue );
</pre><p>and magma_tally4_zsolverinfo_free( &amp;zopts.solver_par, &amp;zopts.precond_par, queue );</p>
<p>Finally, we clean up the used memory via </p><pre class="fragment">    magma_tally4_z_mfree(&amp;B_d, queue );
    magma_tally4_z_mfree(&amp;B, queue );
    magma_tally4_z_vfree(&amp;x_d, queue );
    magma_tally4_z_vfree(&amp;b_d, queue );
</pre><p>and </p><pre class="fragment">    magma_tally4_dsolverinfo_free( &amp;dopts.solver_par, &amp;dopts.precond_par, queue );</pre> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon May 11 2015 10:07:12 for MAGMA_tally4 by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.7 </li>
  </ul>
</div>
</body>
</html>
