diff -aur magma_mgemm2.cloned/Makefile.internal magma_mgemm2/Makefile.internal
--- magma_mgemm2.cloned/Makefile.internal	2019-01-11 09:20:24.090079000 -0500
+++ magma_mgemm2/Makefile.internal	2019-01-11 09:25:44.046761000 -0500
@@ -84,6 +84,9 @@
 ifneq ($(findstring Kepler, $(GPU_TARGET)),)
     GPU_TARGET += sm30 sm35
 endif
+ifneq ($(findstring Volta, $(GPU_TARGET)),)
+    GPU_TARGET += sm70
+endif
 
 #
 # Next, add compile options for specific smXX
@@ -123,6 +126,11 @@
     NV_SM    += -gencode arch=compute_35,code=sm_35
     NV_COMP  := -gencode arch=compute_35,code=compute_35
 endif
+ifneq ($(findstring sm70, $(GPU_TARGET)),)
+    MIN_ARCH ?= 350
+    NV_SM    += -gencode arch=compute_70,code=sm_70
+    NV_COMP  := -gencode arch=compute_70,code=compute_70
+endif
 ifeq ($(NV_COMP),)
     $(error GPU_TARGET, currently $(GPU_TARGET), must contain one or more of Tesla, Fermi, Kepler, or sm{10,13,20,30,35}. Please edit your make.inc file)
 endif
diff -aur magma_mgemm2.cloned/magma_mgemm2blas/gemm_stencil.cuh magma_mgemm2/magma_mgemm2blas/gemm_stencil.cuh
--- magma_mgemm2.cloned/magma_mgemm2blas/gemm_stencil.cuh	2019-01-11 09:20:22.991799000 -0500
+++ magma_mgemm2/magma_mgemm2blas/gemm_stencil.cuh	2019-01-11 09:24:41.371870000 -0500
@@ -138,6 +138,245 @@
 #define THR_M ( BLK_M / DIM_X )
 #define THR_N ( BLK_N / DIM_Y )
 
+//---BEGIN ADDED GENOMICS_METRICS
+//-----------------------------------------------------------------------------
+
+//http://docs.nvidia.com/cuda/cuda-math-api/group__CUDA__MATH__INTRINSIC__INT.html
+//__DEVICE_FUNCTIONS_DECL__ int __popc ( unsigned int  x )
+//Count the number of bits that are set to 1 in a 32 bit integer.
+//__DEVICE_FUNCTIONS_DECL__ int __popcll ( unsigned long long int x )
+//Count the number of bits that are set to 1 in a 64 bit integer.
+
+#if (version == trans_tn) && (precision == z)
+
+#define gm_popcount64(x) __popcll(x)
+
+extern "C" static __device__
+FloatingPoint_t mgemm2_compute(
+    FloatingPoint_t A,
+    FloatingPoint_t B,
+    FloatingPoint_t C)
+{
+    typedef unsigned long long int GMUInt64;
+    typedef GMUInt64 GMBits1_2x64;
+    typedef struct { GMBits1_2x64 data[2]; } GMBits2x64;
+    enum { GM_TALLY1_MAX_VALUE_BITS = 25 };
+    typedef struct { double data[2]; } GMTally2x2;
+
+    GMTally2x2 sum = *(GMTally2x2*)&C;
+
+    /*---Extract input values to process---*/
+
+    const GMBits2x64 vi = *(GMBits2x64*)&A;
+    const GMBits2x64 vj = *(GMBits2x64*)&B;
+
+#if 1
+    const GMUInt64 oddbits = 0x5555555555555555;
+    
+    const GMUInt64& vi0 = vi.data[0];
+    const GMUInt64& vi1 = vi.data[1];
+    const GMUInt64& vj0 = vj.data[0];
+    const GMUInt64& vj1 = vj.data[1];
+
+    const GMUInt64 nvi0 = ~vi.data[0];
+    const GMUInt64 nvi1 = ~vi.data[1];
+    const GMUInt64 nvj0 = ~vj.data[0];
+    const GMUInt64 nvj1 = ~vj.data[1];
+
+    const GMUInt64 vj0s = ((vj0 >> 1) & oddbits) | ((vj0 & oddbits) << 1);
+    const GMUInt64 vj1s = ((vj1 >> 1) & oddbits) | ((vj1 & oddbits) << 1);
+
+    const GMUInt64 r01 = gm_popcount64(nvi0 &  vj0) +
+                         gm_popcount64(nvi0 &  vj0s) +
+                         gm_popcount64(nvi1 &  vj1) +
+                         gm_popcount64(nvi1 &  vj1s);   
+
+    const GMUInt64 nvj0s = ~vj0s;
+    const GMUInt64 nvj1s = ~vj1s;
+    
+    const GMUInt64 r00 = gm_popcount64(nvi0 & nvj0) +
+                         gm_popcount64(nvi0 & nvj0s) +
+                         gm_popcount64(nvi1 & nvj1) +
+                         gm_popcount64(nvi1 & nvj1s);
+    
+    const GMUInt64 r10 = gm_popcount64( vi0 & nvj0) +
+                         gm_popcount64( vi0 & nvj0s) +
+                         gm_popcount64( vi1 & nvj1) +
+                         gm_popcount64( vi1 & nvj1s);
+
+    const GMUInt64 r11 = 4 * 64 - r00 - r01 - r10;
+        
+    /*---Accumulate---*/
+        
+    sum.data[0] += r00 | (r01 << GM_TALLY1_MAX_VALUE_BITS);
+    sum.data[1] += r10 | (r11 << GM_TALLY1_MAX_VALUE_BITS);
+#endif
+
+#if 0
+    //--------------------
+    // Nomenclature:
+    //
+    // ( ) v(i)(0)_(0)
+    // (n) v(j)(1)_(1)
+    //  ^    ^ ^   ^
+    //  |    | |   |--- lower or upper bit of each seminibble
+    //  |    | |--- lower or upper word
+    //  |    |--- left or right vector
+    //  |---test for value or for its negative/complement
+    //--------------------
+
+    const GMUInt64 vi0 = vi.data[0];
+    const GMUInt64 vi1 = vi.data[1];
+    const GMUInt64 vj0 = vj.data[0];
+    const GMUInt64 vj1 = vj.data[1];
+
+    /*---Get even, odd bits for each semi-nibble, masked to active---*/
+
+    const GMUInt64 oddbits = 0x5555555555555555;
+
+    const GMUInt64 vi0_0 =  vi0       & oddbits;
+    const GMUInt64 vi0_1 = (vi0 >> 1) & oddbits;
+    const GMUInt64 vi1_0 =  vi1       & oddbits;
+    const GMUInt64 vi1_1 = (vi1 >> 1) & oddbits;
+    const GMUInt64 vj0_0 =  vj0       & oddbits;
+    const GMUInt64 vj0_1 = (vj0 >> 1) & oddbits;
+    const GMUInt64 vj1_0 =  vj1       & oddbits;
+    const GMUInt64 vj1_1 = (vj1 >> 1) & oddbits;
+
+    /*---Get complements of the same bits, set other bits zero---*/
+
+    const GMUInt64 nvi0_0 = ~ vi0       & oddbits;
+    const GMUInt64 nvi0_1 = ~(vi0 >> 1) & oddbits;
+    const GMUInt64 nvi1_0 = ~ vi1       & oddbits;
+    const GMUInt64 nvi1_1 = ~(vi1 >> 1) & oddbits;
+    const GMUInt64 nvj0_0 = ~ vj0       & oddbits;
+    const GMUInt64 nvj0_1 = ~(vj0 >> 1) & oddbits;
+    const GMUInt64 nvj1_0 = ~ vj1       & oddbits;
+    const GMUInt64 nvj1_1 = ~(vj1 >> 1) & oddbits;
+
+    const int r00 = gm_popcount64((nvi0_0 & nvj0_0) |
+                                ( (nvi0_0 & nvj0_1) << 1 )) +
+                    gm_popcount64((nvi0_1 & nvj0_0) |
+                                ( (nvi0_1 & nvj0_1) << 1 )) +
+                    gm_popcount64((nvi1_0 & nvj1_0) |
+                                ( (nvi1_0 & nvj1_1) << 1 )) +
+                    gm_popcount64((nvi1_1 & nvj1_0) |
+                                ( (nvi1_1 & nvj1_1) << 1 ));
+    const int r01 = gm_popcount64((nvi0_0 &  vj0_0) |
+                                ( (nvi0_0 &  vj0_1) << 1 )) +
+                    gm_popcount64((nvi0_1 &  vj0_0) |
+                                ( (nvi0_1 &  vj0_1) << 1 )) +
+                    gm_popcount64((nvi1_0 &  vj1_0) |
+                                ( (nvi1_0 &  vj1_1) << 1 )) +
+                    gm_popcount64((nvi1_1 &  vj1_0) |
+                                ( (nvi1_1 &  vj1_1) << 1 ));
+    const int r10 = gm_popcount64(( vi0_0 & nvj0_0) |
+                                ( ( vi0_0 & nvj0_1) << 1 )) +
+                    gm_popcount64(( vi0_1 & nvj0_0) |
+                                ( ( vi0_1 & nvj0_1) << 1 )) +
+                    gm_popcount64(( vi1_0 & nvj1_0) |
+                                ( ( vi1_0 & nvj1_1) << 1 )) +
+                    gm_popcount64(( vi1_1 & nvj1_0) |
+                                ( ( vi1_1 & nvj1_1) << 1 ));
+    const int r11 = gm_popcount64(( vi0_0 &  vj0_0) |
+                                ( ( vi0_0 &  vj0_1) << 1 )) +
+                    gm_popcount64(( vi0_1 &  vj0_0) |
+                                ( ( vi0_1 &  vj0_1) << 1 )) +
+                    gm_popcount64(( vi1_0 &  vj1_0) |
+                                ( ( vi1_0 &  vj1_1) << 1 )) +
+                    gm_popcount64(( vi1_1 &  vj1_0) |
+                                ( ( vi1_1 &  vj1_1) << 1 ));
+
+    /*---Accumulate---*/
+
+    sum.data[0] += r00 + (((GMUInt64)1)<<GM_TALLY1_MAX_VALUE_BITS) * r01;
+    sum.data[1] += r10 + (((GMUInt64)1)<<GM_TALLY1_MAX_VALUE_BITS) * r11;
+#endif
+
+#if 0
+    /*---This code reduces register pressure but runs somewhat slower---*/
+
+    const GMUInt64 oddbits = 0x5555555555555555;
+
+{
+    const GMUInt64 vi0 = vi.data[0];
+    const GMUInt64 vi0_0 =  vi0       & oddbits;
+    const GMUInt64 vi0_1 = (vi0 >> 1) & oddbits;
+    const GMUInt64 nvi0_0 = ~ vi0       & oddbits;
+    const GMUInt64 nvi0_1 = ~(vi0 >> 1) & oddbits;
+
+    const GMUInt64 vj0 = vj.data[0];
+    const GMUInt64 vj0_0 =  vj0       & oddbits;
+    const GMUInt64 vj0_1 = (vj0 >> 1) & oddbits;
+    const GMUInt64 nvj0_0 = ~ vj0       & oddbits;
+    const GMUInt64 nvj0_1 = ~(vj0 >> 1) & oddbits;
+
+    const int r00 = gm_popcount64((nvi0_0 & nvj0_0) |
+                                ( (nvi0_0 & nvj0_1) << 1 )) +
+                    gm_popcount64((nvi0_1 & nvj0_0) |
+                                ( (nvi0_1 & nvj0_1) << 1 ));
+    const int r01 = gm_popcount64((nvi0_0 &  vj0_0) |
+                                ( (nvi0_0 &  vj0_1) << 1 )) +
+                    gm_popcount64((nvi0_1 &  vj0_0) |
+                                ( (nvi0_1 &  vj0_1) << 1 ));
+    const int r10 = gm_popcount64(( vi0_0 & nvj0_0) |
+                                ( ( vi0_0 & nvj0_1) << 1 )) +
+                    gm_popcount64(( vi0_1 & nvj0_0) |
+                                ( ( vi0_1 & nvj0_1) << 1 ));
+    const int r11 = gm_popcount64(( vi0_0 &  vj0_0) |
+                                ( ( vi0_0 &  vj0_1) << 1 )) +
+                    gm_popcount64(( vi0_1 &  vj0_0) |
+                                ( ( vi0_1 &  vj0_1) << 1 ));
+
+    /*---Accumulate---*/
+
+    sum.data[0] += r00 + (((GMUInt64)1)<<GM_TALLY1_MAX_VALUE_BITS) * r01;
+    sum.data[1] += r10 + (((GMUInt64)1)<<GM_TALLY1_MAX_VALUE_BITS) * r11;
+}
+{
+    const GMUInt64 vi1 = vi.data[1];
+    const GMUInt64 vi1_0 =  vi1       & oddbits;
+    const GMUInt64 vi1_1 = (vi1 >> 1) & oddbits;
+    const GMUInt64 nvi1_0 = ~ vi1       & oddbits;
+    const GMUInt64 nvi1_1 = ~(vi1 >> 1) & oddbits;
+
+    const GMUInt64 vj1 = vj.data[1];
+    const GMUInt64 vj1_0 =  vj1       & oddbits;
+    const GMUInt64 vj1_1 = (vj1 >> 1) & oddbits;
+    const GMUInt64 nvj1_0 = ~ vj1       & oddbits;
+    const GMUInt64 nvj1_1 = ~(vj1 >> 1) & oddbits;
+
+    const int r00 = gm_popcount64((nvi1_0 & nvj1_0) |
+                                ( (nvi1_0 & nvj1_1) << 1 )) +
+                    gm_popcount64((nvi1_1 & nvj1_0) |
+                                ( (nvi1_1 & nvj1_1) << 1 ));
+    const int r01 = gm_popcount64((nvi1_0 &  vj1_0) |
+                                ( (nvi1_0 &  vj1_1) << 1 )) +
+                    gm_popcount64((nvi1_1 &  vj1_0) |
+                                ( (nvi1_1 &  vj1_1) << 1 ));
+    const int r10 = gm_popcount64(( vi1_0 & nvj1_0) |
+                                ( ( vi1_0 & nvj1_1) << 1 )) +
+                    gm_popcount64(( vi1_1 & nvj1_0) |
+                                ( ( vi1_1 & nvj1_1) << 1 ));
+    const int r11 = gm_popcount64(( vi1_0 &  vj1_0) |
+                                ( ( vi1_0 &  vj1_1) << 1 )) +
+                    gm_popcount64(( vi1_1 &  vj1_0) |
+                                ( ( vi1_1 &  vj1_1) << 1 ));
+
+    /*---Accumulate---*/
+
+    sum.data[0] += r00 + (((GMUInt64)1)<<GM_TALLY1_MAX_VALUE_BITS) * r01;
+    sum.data[1] += r10 + (((GMUInt64)1)<<GM_TALLY1_MAX_VALUE_BITS) * r11;
+}
+#endif
+
+//printf("%i %i %i %i %e %e\n", r00, r01, r10, r11, sum.data[0], sum.data[1]);
+    return *(FloatingPoint_t*)&sum;
+}
+#endif
+
+//-----------------------------------------------------------------------------
+//---END ADDED GENOMICS_METRICS
 ///////////////////////////////////////////////////////////////////////////////////////////////////
 extern "C" static __device__
 void devfunc_name(precision) (
@@ -344,7 +583,13 @@
                       #ifdef CONJ_B
                         fma(rA[m], conj(rB[n]), rC[n][m]);
                       #else
-                        fma(rA[m], rB[n], rC[n][m]);
+                        //---BEGIN MODIFIED GENOMICS_METRICS
+                        #if (version == trans_tn) && (precision == z)
+                          rC[n][m] = mgemm2_compute(rA[m], rB[n], rC[n][m]);
+                        #else
+                          fma(rA[m], rB[n], rC[n][m]);
+                        #endif
+                        //---END MODIFIED GENOMICS_METRICS
                       #endif
                     #endif
                 }
@@ -419,7 +664,13 @@
                   #ifdef CONJ_B
                     fma(rA[m], conj(rB[n]), rC[n][m]);
                   #else
-                    fma(rA[m], rB[n], rC[n][m]);
+                    //---BEGIN MODIFIED GENOMICS_METRICS
+                    #if (version == trans_tn) && (precision == z)
+                      rC[n][m] = mgemm2_compute(rA[m], rB[n], rC[n][m]);
+                    #else
+                      fma(rA[m], rB[n], rC[n][m]);
+                    #endif
+                    //---END MODIFIED GENOMICS_METRICS
                   #endif
                 #endif
             }
