#!/usr/bin/env python
"""
-------------------------------------------------------------------------------
settings_advisor: suggest settings for running CoMet code.
-------------------------------------------------------------------------------
"""

import argparse

#------------------------------------------------------------------------------

def process_command_line_args():
    """Get the command line arguments."""

    command_description = (
        'Suggest settings for running the CoMet code.')

    num_node_help = ('The number of compute nodes to run on.')
    platform_help = ('Platform to be run on (Titan or Summit)')
    num_way_help = ('dimension of metric to compute (2-way or 3-way)')
    metric_type_help = ('metric type (czekanowski or ccc)')
    num_vector_help = ('number of vectors to process')
    num_field_help = ('number of fields to process')
    precision_help = ('Whether using single or double (default) precision')
    sparse_help = ('Whether sparse input (default yes)')

    parser = argparse.ArgumentParser(description=command_description)
    parser.add_argument('--num_node', help=num_node_help, required=True)
    parser.add_argument('--platform', help=platform_help, required=True,
                        choices=['Titan', 'Summit'])
    parser.add_argument('--num_way', help=num_way_help, required=True,
                        choices=['2', '3'])
    parser.add_argument('--metric_type', help=metric_type_help, required=True,
                        choices=['czekanowski', 'ccc'])
    parser.add_argument('--num_vector', help=num_vector_help, required=True)
    parser.add_argument('--num_field', help=num_field_help, required=True)
    parser.add_argument('--precision', help=precision_help, required=False,
                        choices=['single', 'double'], default='double')
    parser.add_argument('--sparse', help=sparse_help, required=False,
                        choices=['yes', 'no'], default='yes')

    args = parser.parse_args()

    return args

#------------------------------------------------------------------------------

def is_titan(args):
    """ """
    return args.platform == 'Titan'

#------------------------------------------------------------------------------

def is_ccc(args):
    """ """
    return args.metric_type == 'ccc'

#------------------------------------------------------------------------------

def is_sparse(args):
    """ """
    return args.sparse == 'yes'

#------------------------------------------------------------------------------

def proc_per_node(args):
    """ """
    return 1 if is_titan(args) else 6

#------------------------------------------------------------------------------

def num_node_avail(args):
    """ """
    return int(args.num_node)

#------------------------------------------------------------------------------

def num_proc_avail(args):
    """ """
    return num_node_avail(args) * proc_per_node(args)

#------------------------------------------------------------------------------

def num_way(args):
    """ """
    return int(args.num_way)

#------------------------------------------------------------------------------

def is_double(args):
    """ """
    return args.precision == 'double'

#------------------------------------------------------------------------------

def num_vector(args):
    """ """
    result = int(args.num_vector)
    assert result > 0, 'Nonzero number of vectors required.'
    return result

#------------------------------------------------------------------------------

def num_field(args):
    """ """
    result = int(args.num_field)
    assert result > 0, 'Nonzero number of fields required.'
    return result

#------------------------------------------------------------------------------

def gpu_bytes_per_proc_avail(args):
    """ """
    GiB = 1024. * 1024. * 1024.
    return int((5.25 if is_titan(args) else 15.5) * GiB)

#------------------------------------------------------------------------------

def cpu_bytes_per_proc_avail(args):
    """ """
    GiB = 1024. * 1024. * 1024.
    return int((32.*.95 if is_titan(args) else 512.*.95) /
               proc_per_node(args) * GiB)

#==============================================================================

def int_floor(i, j):
    """ """
    assert i >= 0
    assert j > 0
    assert isinstance(i, int)
    assert isinstance(j, int)

    return int(i / j)

#------------------------------------------------------------------------------

def int_ceil(i, j):
    """ """
    assert i >= 0
    assert j > 0
    assert isinstance(i, int)
    assert isinstance(j, int)

    return int((i+j-1) / j)

#------------------------------------------------------------------------------

def bits_per_vector_elt(args):
    """ """
    sizeof_double = 8
    sizeof_float = 4

    return 2 if is_ccc(args) else (
           8*sizeof_double if is_double(args) else (
           8*sizeof_float))

#------------------------------------------------------------------------------

def bytes_per_metric_elt(args):
    """ """
    sizeof_double = 8
    sizeof_float = 4

    return ((1 << num_way(args))/2) * sizeof_double if is_ccc(args) else (
           sizeof_double if is_double(args) else (
           sizeof_float))

#------------------------------------------------------------------------------

def bytes_per_metric(args):
    """ """
    sizeof_double = 8
    sizeof_int64 = 8

    elt_size_index = sizeof_int64
    elt_size_S = sizeof_double if is_ccc(args) else 0
    elt_size_C = sizeof_double if is_sparse(args) and is_ccc(args) else 0

    return bytes_per_metric_elt(args) + elt_size_index + elt_size_S + elt_size_C

#------------------------------------------------------------------------------

def num_vector_local(settings, args):
    """ """
    num_proc_vector = settings['num_proc_vector']
    assert num_proc_vector > 0
    assert isinstance(num_proc_vector, int)

    return int_ceil(num_vector(args), num_proc_vector)

#------------------------------------------------------------------------------

def num_field_local(settings, args):
    """ """
    num_proc_field = settings['num_proc_field']
    assert num_proc_field > 0
    assert isinstance(num_proc_field, int)

    return int_ceil(num_field(args), num_proc_field)

#------------------------------------------------------------------------------

def bytes_per_vectors_block(settings, args):
    """Memory required to store an on-proc portion of the set of vectors."""
    num_proc_vector = settings['num_proc_vector']
    assert num_proc_vector > 0
    assert isinstance(num_proc_vector, int)

    num_proc_field = settings['num_proc_field']

    num_field_local_ = num_field_local(settings, args)

    bits_per_byte = 8
    bytes_per_vector = int_ceil(num_field_local_ * bits_per_vector_elt(args),
                                bits_per_byte)

    return bytes_per_vector * num_vector_local(settings, args)

#------------------------------------------------------------------------------

def bytes_per_metrics_block(settings, args):
    """Memory required to store an on-proc blc=ock of metrics values."""
    num_proc_vector = settings['num_proc_vector']
    assert num_proc_vector > 0
    assert isinstance(num_proc_vector, int)

    num_vector_local_ = num_vector_local(settings, args)

    return bytes_per_metric_elt(args) * num_vector_local_ * num_vector_local_

#------------------------------------------------------------------------------

def gpu_bytes_per_proc_used(settings, args):
    """ """
    num_proc_vector = settings['num_proc_vector']
    assert num_proc_vector > 0
    assert isinstance(num_proc_vector, int)

    bytes_per_vectors_block_ = bytes_per_vectors_block(settings, args)
    bytes_per_metrics_block_ = bytes_per_metrics_block(settings, args)

    if num_way(args) == 2:

        return 3 * bytes_per_vectors_block_ + 3 * bytes_per_metrics_block_

    else:

        bytes_part1 = bytes_per_vectors_block_

        bytes_part2 = bytes_per_vectors_block_

        bytes_part3 = bytes_per_vectors_block_

        bytes_num_create = (2 * bytes_per_vectors_block_ +
                            2 * bytes_per_metrics_block_)

        if settings['num_proc_field'] > 1:
            bytes_num_create += 2 * bytes_per_metrics_block_

        if not is_ccc(args):
            bytes_num_create += 3 * bytes_per_metrics_block_

        result = bytes_num_create + bytes_part1 + bytes_part2 + bytes_part3

        return result

#------------------------------------------------------------------------------

def cpu_bytes_per_proc_used(settings, args):
    """ """
    num_proc_vector = settings['num_proc_vector']
    num_phase = settings['num_phase']
    num_stage = settings['num_stage']
    assert num_proc_vector > 0
    assert num_phase > 0
    assert isinstance(num_proc_vector, int)
    assert isinstance(num_phase, int)

    bytes_per_vectors_block_ = bytes_per_vectors_block(settings, args)
    bytes_per_metrics_block_ = bytes_per_metrics_block(settings, args)

    num_vector_local_ = num_vector_local(settings, args)

    num_proc_repl_ = settings['num_proc_repl']

    if num_way(args) == 2:

        result = 4 * bytes_per_vectors_block_ + 3 * bytes_per_metrics_block_

        num_block_local = int_ceil(int_ceil(int_ceil(num_proc_vector, 2),
                                                     num_proc_repl_), num_phase)
        num_metrics_elts_local = (num_vector_local_ * num_vector_local_ *
                              num_block_local)

        bytes_metrics_local = num_metrics_elts_local * bytes_per_metric(args) 

        result += bytes_metrics_local

        return result

    else:

        bytes_part1 = bytes_per_vectors_block_

        bytes_part2 = 3*bytes_per_vectors_block_

        bytes_part3 = 3*bytes_per_vectors_block_

        bytes_num_create = (3 * bytes_per_vectors_block_ +
                            2 * bytes_per_metrics_block_)

        if settings['num_proc_field'] > 1:
            bytes_num_create += 2 * bytes_per_metrics_block_

        if not is_ccc(args):
            bytes_num_create += 3 * bytes_per_metrics_block_

        result = bytes_num_create + bytes_part1 + bytes_part2 + bytes_part3

        planes_per_block = int_ceil(num_vector_local_, 6*num_stage)

        num_block = int_ceil(num_proc_vector*num_proc_vector, num_proc_repl_)

        num_metrics_elts_local = (num_vector_local_ * num_vector_local_ *
                                  planes_per_block * num_block)

        bytes_metrics_local = num_metrics_elts_local * bytes_per_metric(args) 

        result += bytes_metrics_local

        return result

#------------------------------------------------------------------------------

def main():
    """Main program for determining good CoMet settings."""

    # Get the command line arguments.

    args = process_command_line_args()

    #print(cpu_bytes_per_proc_used(6000, 200, args)/1000000000.,
    #      gpu_bytes_per_proc_used(6000, args)/1000000000.)

    cpu_bytes_per_proc_avail_ = cpu_bytes_per_proc_avail(args)
    gpu_bytes_per_proc_avail_ = gpu_bytes_per_proc_avail(args)

    settings = {'num_proc_vector': 1,
                'num_proc_field': 1,
                'num_proc_repl': 1,
                'num_phase': 1,
                'num_stage': 1}

    # First determine how many compute nodes needed.

    num_proc_avail_ = num_proc_avail(args)
    settings['num_proc_vector'] = num_proc_avail_
    gpu_bytes_per_proc_used_ = gpu_bytes_per_proc_used(settings, args)

    GB = 1000. * 1000. * 1000.

    if gpu_bytes_per_proc_used_ <= gpu_bytes_per_proc_avail_:
        print('GPU memory: ' +
              str(gpu_bytes_per_proc_used_/GB) +
              ' GB required out of ' +
              str(gpu_bytes_per_proc_avail_/GB) +
              ' GB available: OK.')
    else:
        print('Insufficient GPU memory, please increase num_node.')
        print('GPU memory: ' +
              str(gpu_bytes_per_proc_used_/GB) +
              ' GB requested out of ' +
              str(gpu_bytes_per_proc_avail_/GB) +
              ' GB available.')
        return

    for num_phase in range(1,int(1+settings['num_proc_vector']/2)+1):
        settings['num_phase'] = num_phase
        cpu_bytes_per_proc_used_ = cpu_bytes_per_proc_used(settings, args)
        if cpu_bytes_per_proc_used_ <= cpu_bytes_per_proc_avail_:
            break

    cpu_bytes_per_proc_used_ = cpu_bytes_per_proc_used(settings, args)

    if cpu_bytes_per_proc_used_ <= cpu_bytes_per_proc_avail_:
        print('To fit into memory, suggest using num_phase = ' +
              str(settings['num_phase']) + ' (or higher). Then:')
        print('CPU memory: ' +
              str(cpu_bytes_per_proc_used_/GB) +
              ' GB required out of ' +
              str(cpu_bytes_per_proc_avail_/GB) +
              ' GB available: OK.')
    else:
        print('Insufficient CPU memory, please increase num_node.')
        print('Using num_phase = ' + str(settings['num_phase']) +
               ' at this node count:')
        print('CPU memory: ' +
              str(cpu_bytes_per_proc_used_/GB) +
              ' GB requested out of ' +
              str(cpu_bytes_per_proc_avail_/GB) +
              ' GB available.')
        return

    if settings['num_phase'] > 1:
        print('Suggest executing at least several phases per run ' +
              'to amortize setup costs.')

    num_vector_local_target = 4000

    num_vector_local_ =  num_vector_local(settings, args)

    print('Local problem size: num_vector_local = ' + str(num_vector_local_) +
          ', target = ' + str(num_vector_local_target) + '.')

    if num_vector_local_ < num_vector_local_target:
        print('Suggest lowering num_nodes to improve performance.')

#------------------------------------------------------------------------------

if __name__ == '__main__':

    print('-' * 79)
    main()
    print('-' * 79)

#------------------------------------------------------------------------------
